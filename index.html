<!DOCTYPE html>
<html lang="en">

<body>
    <video id="videoPlayer" controls style="max-width: 400px;"></video>
    <div id="stats">
        <p>Transactions downloaded: <span id="chunksDownloaded">0</span></p>
        <p>MBs downloaded: <span id="mbsDownloaded">0.00</span> MB</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js" integrity="sha512-f+t6//rz3Iy3hp1CiwtsigYtyWuGk7bf6xl2RTOPvmyMIfTQJ4iy6Lg1dah1bsLQ9SLideJGicgmOkBsBXP1aA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script>
        let mediaSource;
        let sourceBuffer;
        let currentSegment = 0;
        const segmentPrefix = 'segment_';
        const delay = 200; // Delay between segments in milliseconds
        let totalBytesDownloaded = 0;
        let chunksDownloaded = 0;
        let contract;
        let videoId;
        let totalChunks;

        async function loadVideo() {
            // Get video ID from URL
            const urlParams = new URLSearchParams(window.location.search);
            videoId = urlParams.get('video');
            if (!videoId) {
                console.error('No video ID provided in the URL');
                return;
            }

            // Initialize contract
            await initializeContract();

            // Get video details
            const videoDetails = await contract.getVideo(videoId);
            totalChunks = videoDetails.chunkIds.length;

            setupMediaSource();
        }

        async function initializeContract() {
            // Load ABI and contract address
            const response = await fetch('contract/abi.json');
            const abi = await response.json();
            const contractAddress = '0xe9b1324f531a4603eb5d1a739e4ee25a5c824890';

            // Connect to Ethereum provider (e.g., MetaMask)
            await window.ethereum.request({ method: 'eth_requestAccounts' });

            const provider = new ethers.BrowserProvider(window.ethereum);
            const signer = await provider.getSigner();

            // Create contract instance
            contract = new ethers.Contract(contractAddress, abi, signer);
        }

        function setupMediaSource() {
            const video = document.getElementById('videoPlayer');
            mediaSource = new MediaSource();
            video.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', sourceOpen);
        }

        async function sourceOpen() {
            // Fetch video metadata from the contract
            const videoDetails = await contract.getVideo(videoId);
            const metadata = JSON.parse(videoDetails.metadata || '{}');
            
            // Use the codec from metadata, or fall back to a default if not available
            const mimeCodec = metadata.codec || 'video/mp4; codecs="avc1.64002A, mp4a.40.5"';
            
            if (!MediaSource.isTypeSupported(mimeCodec)) {
                console.error('Unsupported MIME type or codec: ', mimeCodec);
                return;
            }

            try {
                sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
                loadNextSegment();
            } catch (e) {
                console.error('Exception while adding source buffer', e);
            }
        }

        async function loadNextSegment() {
            if (currentSegment >= totalChunks) {
                mediaSource.endOfStream();
                return;
            }

            try {
                // Fetch chunk from the blockchain
                const chunkData = await contract.getChunk(currentSegment);

                // Convert hex string to ArrayBuffer
                const segmentBuffer = hexToArrayBuffer(chunkData);

                // Check if sourceBuffer is too big
                await waitForSourceBuffer();
                console.log('Appending segment:', currentSegment);
                console.log(segmentBuffer);
                sourceBuffer.appendBuffer(segmentBuffer);
                currentSegment++;

                // Update stats
                chunksDownloaded++;
                totalBytesDownloaded += segmentBuffer.byteLength;
                updateStats();

                // Wait for the segment to be processed before loading the next one
                sourceBuffer.addEventListener('updateend', () => {
                    setTimeout(loadNextSegment, delay);
                }, { once: true });
            } catch (error) {
                console.error('Error loading segment:', error);
                mediaSource.endOfStream();
            }
        }

        function hexToArrayBuffer(hexString) {
            const bytes = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            return bytes.buffer;
        }

        function waitForSourceBuffer() {
            return new Promise((resolve) => {
                const checkBuffer = () => {
                    const sizeThreshold = 10 * 1024 * 1024; // 50 MB

                    if (sourceBuffer.buffered.length > 0) {
                        const bufferEnd = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
                        
                        // Estimate buffer size (this is an approximation)
                        const estimatedBufferSize = totalBytesDownloaded - (document.getElementById('videoPlayer').currentTime * (totalBytesDownloaded / bufferEnd));

                        if (estimatedBufferSize < sizeThreshold) {
                            resolve();
                        } else {
                            setTimeout(checkBuffer, 1000); // Check again after 1 second
                        }
                    } else {
                        resolve(); // If there's no buffered data, proceed with appending
                    }
                };
                checkBuffer();
            });
        }

        function updateStats() {
            document.getElementById('chunksDownloaded').textContent = chunksDownloaded;
            const mbsDownloaded = (totalBytesDownloaded / (1024 * 1024)).toFixed(2);
            document.getElementById('mbsDownloaded').textContent = mbsDownloaded;
        }

        // Initialize the video loading
        loadVideo();

        // Error handling for video element
        const video = document.getElementById('videoPlayer');
        video.addEventListener('error', function () {
            console.error('Video error:', video.error);
        });
    </script>
</body>

</html>