<!DOCTYPE html>
<html lang="en">

<head>    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onchain Video Player</title>
    <link rel="stylesheet" href="/style.css">

    <link rel="stylesheet" href="/fontawesome-free-6.6.0-web/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js" integrity="sha512-f+t6//rz3Iy3hp1CiwtsigYtyWuGk7bf6xl2RTOPvmyMIfTQJ4iy6Lg1dah1bsLQ9SLideJGicgmOkBsBXP1aA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <meta property="og:title" content="Onchain Video - upload and watch videos on the Blast blockchain" />
    <meta property="og:url" content="https://onchainvideo.win/" />
    <meta property="og:image" content="https://onchainvideo.win/og-player.png" />
    <!-- Twitter Card tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Onchain Video">
    <meta name="twitter:description" content="Watch videos on the blockchain" />
    <meta name="twitter:image" content="https://onchainvideo.win/og-player.png">
</head>

<body>
    <h1><a href="/">Onchain Video</a> Player</h1>
    <p id="instructionText">Loading video from the blockchain...</p>
    
    <video id="videoPlayer" controls style="max-width: 400px;"></video>
    <div id="stats">
        <p><span id="fileName">Loading...</span></p>
        <p><span id="mbsDownloaded">0.00</span> MB downloaded from <span id="chunksDownloaded">0</span> blockchain transactions.</p>
    </div>
    <script>
        let mediaSource;
        let sourceBuffer;
        let chunkIds = []; // Array to store chunk IDs
        let currentChunkIndex = 0;
        const delay = 200; // Delay between segments in milliseconds
        let totalBytesDownloaded = 0;
        let chunksDownloaded = 0;
        let contract;
        let videoId;

        const RPC_URL = 'https://rpc.blast.io'; // Public RPC endpoint for Blast
        const CONTRACT_ADDRESS = '0x1F00F51E00F10c019617fB4A50d4E893aaf8C98c';

        async function loadVideo() {
            // Get video ID from URL
            const urlParams = new URLSearchParams(window.location.search);
            videoId = urlParams.get('v');
            if (!videoId) {
                console.error('No video ID provided in the URL');
                document.getElementById('fileName').textContent = 'Error: No video ID provided';
                return;
            }

            await initializeContract();
            
            // Get video details
            const videoDetails = await contract.getVideo(videoId);
            chunkIds = videoDetails.chunkIds;

            // Update file name in stats
            document.getElementById('fileName').textContent = videoDetails.filename || 'Unknown';

            setupMediaSource();
        }

        async function initializeContract() {
            // Load ABI and contract address
            const response = await fetch('/abi.json');
            const abi = await response.json();

            // Create a read-only provider
            const provider = new ethers.JsonRpcProvider(RPC_URL);

            // Create contract instance
            contract = new ethers.Contract(CONTRACT_ADDRESS, abi, provider);
        }

        function setupMediaSource() {
            const video = document.getElementById('videoPlayer');
            mediaSource = new MediaSource();
            video.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', sourceOpen);
        }

        async function sourceOpen() {
            // Fetch video metadata from the contract
            const videoDetails = await contract.getVideo(videoId);
            const metadata = JSON.parse(videoDetails.metadata || '{}');
            
            // Use the codec from metadata, or fall back to a default if not available
            const mimeCodec = metadata.codec || 'video/mp4; codecs="avc1.64002A, mp4a.40.5"';
            
            if (!MediaSource.isTypeSupported(mimeCodec)) {
                console.error('Unsupported MIME type or codec: ', mimeCodec);
                return;
            }

            try {
                sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
                loadNextSegment();
            } catch (e) {
                console.error('Exception while adding source buffer', e);
            }
        }

        async function loadNextSegment() {
            if (currentChunkIndex >= chunkIds.length) {
                mediaSource.endOfStream();
                return;
            }

            try {
                // Fetch chunk from the blockchain using the current chunk ID
                const chunkData = await contract.getChunk(chunkIds[currentChunkIndex]);

                // Convert hex string to ArrayBuffer
                const segmentBuffer = hexToArrayBuffer(chunkData);

                // Check if sourceBuffer is too big
                await waitForSourceBuffer();
                sourceBuffer.appendBuffer(segmentBuffer);
                currentChunkIndex++;

                // Update stats
                chunksDownloaded++;
                totalBytesDownloaded += segmentBuffer.byteLength;
                updateStats();

                // Wait for the segment to be processed before loading the next one
                sourceBuffer.addEventListener('updateend', () => {
                    setTimeout(loadNextSegment, delay);
                }, { once: true });
            } catch (error) {
                console.error('Error loading segment:', error);
                mediaSource.endOfStream();
            }
        }

        function hexToArrayBuffer(hexString) {
            // Remove '0x' prefix if present
            const cleanHexString = hexString.startsWith('0x') ? hexString.slice(2) : hexString;
            const bytes = new Uint8Array(cleanHexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            return bytes.buffer;
        }

        function waitForSourceBuffer() {
            return new Promise((resolve) => {
                const checkBuffer = () => {
                    const sizeThreshold = 10 * 1024 * 1024; // 10 MB

                    if (sourceBuffer.buffered.length > 0) {
                        const bufferEnd = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
                        
                        // Estimate buffer size (this is an approximation)
                        const estimatedBufferSize = totalBytesDownloaded - (document.getElementById('videoPlayer').currentTime * (totalBytesDownloaded / bufferEnd));

                        if (estimatedBufferSize < sizeThreshold) {
                            resolve();
                        } else {
                            setTimeout(checkBuffer, 1000); // Check again after 1 second
                        }
                    } else {
                        resolve(); // If there's no buffered data, proceed with appending
                    }
                };
                checkBuffer();
            });
        }

        function updateStats() {
            document.getElementById('chunksDownloaded').textContent = chunksDownloaded;
            const mbsDownloaded = (totalBytesDownloaded / (1024 * 1024)).toFixed(2);
            document.getElementById('mbsDownloaded').textContent = mbsDownloaded;
        }

        // Initialize the video loading
        loadVideo();

        // Add event listener for connect wallet button
        document.getElementById('connectWalletBtn').addEventListener('click', connectWallet);

        // Error handling for video element
        const video = document.getElementById('videoPlayer');
        video.addEventListener('error', function () {
            console.error('Video error:', video.error);
            document.getElementById('fileName').textContent = 'Error: Failed to load video';
        });

        // Add more specific error handling
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            document.getElementById('fileName').textContent = 'Error: An unexpected error occurred';
        });
    </script>
</body>

</html>