<!DOCTYPE html>
<html lang="en">

<head>    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onchain Video Player</title>
    <link rel="stylesheet" href="/style.css">

    <link rel="stylesheet" href="/fontawesome-free-6.6.0-web/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js" integrity="sha512-f+t6//rz3Iy3hp1CiwtsigYtyWuGk7bf6xl2RTOPvmyMIfTQJ4iy6Lg1dah1bsLQ9SLideJGicgmOkBsBXP1aA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <meta property="og:title" content="Onchain Video - upload and watch videos on the Blast blockchain" />
    <meta property="og:url" content="https://onchainvideo.win/" />
    <meta property="og:image" content="https://onchainvideo.win/og-image.png" />
    <!-- Twitter Card tags -->
    <meta name="twitter:title" content="Onchain Video">
    <meta name="twitter:description" content="Watch videos on the blockchain" />
    <meta name="twitter:image" content="https://onchainvideo.win/og-image.png">

    <script>
        let mediaSource;
        let sourceBuffer;
        let chunkIds = []; // Array to store chunk IDs
        let currentChunkIndex = 0;
        const delay = 200; // Delay between segments in milliseconds
        let totalBytesDownloaded = 0;
        let chunksDownloaded = 0;
        let contract;
        let videoId;

        const CHAIN_ID = '0x13e31'; // Blast chain ID

        async function loadVideo() {
            // Get video ID from URL
            const urlParams = new URLSearchParams(window.location.search);
            videoId = urlParams.get('v');
            if (!videoId) {
                console.error('No video ID provided in the URL');
                document.getElementById('fileName').textContent = 'Error: No video ID provided';
                return;
            }

            // Show connect wallet button
            document.getElementById('connectWalletBtn').style.display = 'block';
        }

        async function connectWallet() {
            try {
                // Check if ethereum object is available
                if (typeof window.ethereum !== 'undefined') {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    await checkAndSwitchNetwork();
                    await initializeContract();
                    
                    // Hide connect wallet button and instruction text
                    document.getElementById('connectWalletBtn').style.display = 'none';
                    document.getElementById('instructionText').style.display = 'none';

                    // Show video player and stats
                    document.getElementById('stats').style.display = 'block';

                    // Get video details
                    const videoDetails = await contract.getVideo(videoId);
                    chunkIds = videoDetails.chunkIds;

                    // Update file name in stats
                    document.getElementById('fileName').textContent = videoDetails.filename || 'Unknown';

                    setupMediaSource();
                } else {
                    alert('Please install MetaMask or another Ethereum wallet to use this application.');
                }
            } catch (error) {
                console.error('Failed to connect wallet:', error);
                alert('Failed to connect wallet. Please try again.');
            }
        }

        async function checkAndSwitchNetwork() {
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            if (chainId !== CHAIN_ID) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: CHAIN_ID }],
                    });
                } catch (switchError) {
                    // This error code indicates that the chain has not been added to MetaMask
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: CHAIN_ID,
                                    chainName: 'Blast',
                                    nativeCurrency: {
                                        name: 'Ether',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                    rpcUrls: ['https://rpc.blast.io'],
                                    blockExplorerUrls: ['https://blastscan.io']
                                }],
                            });
                        } catch (addError) {
                            console.error('Failed to add Blast network', addError);
                            alert('Please add the Blast network to your wallet and switch to it.');
                            return;
                        }
                    } else {
                        console.error('Failed to switch to Blast network', switchError);
                        alert('Please switch to the Blast network in your wallet.');
                        return;
                    }
                }
            }
        }

        async function initializeContract() {
            // Load ABI and contract address
            const response = await fetch('/contract/abi.json');
            const abi = await response.json();
            const contractAddress = '0x1F00F51E00F10c019617fB4A50d4E893aaf8C98c';

            // Connect to Ethereum provider (e.g., MetaMask)
            await window.ethereum.request({ method: 'eth_requestAccounts' });

            const provider = new ethers.BrowserProvider(window.ethereum);
            const signer = await provider.getSigner();

            // Create contract instance
            contract = new ethers.Contract(contractAddress, abi, signer);

            // Add event listener for network changes
            window.ethereum.on('chainChanged', (chainId) => {
                if (chainId !== CHAIN_ID) {
                    alert('Please switch back to the Blast network to use this application.');
                    location.reload();
                }
            });
        }

        function setupMediaSource() {
            const video = document.getElementById('videoPlayer');
            mediaSource = new MediaSource();
            video.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', sourceOpen);
        }

        async function sourceOpen() {
            // Fetch video metadata from the contract
            const videoDetails = await contract.getVideo(videoId);
            const metadata = JSON.parse(videoDetails.metadata || '{}');
            
            // Use the codec from metadata, or fall back to a default if not available
            const mimeCodec = metadata.codec || 'video/mp4; codecs="avc1.64002A, mp4a.40.5"';
            
            if (!MediaSource.isTypeSupported(mimeCodec)) {
                console.error('Unsupported MIME type or codec: ', mimeCodec);
                return;
            }

            try {
                sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
                loadNextSegment();
            } catch (e) {
                console.error('Exception while adding source buffer', e);
            }
        }

        async function loadNextSegment() {
            if (currentChunkIndex >= chunkIds.length) {
                mediaSource.endOfStream();
                return;
            }

            try {
                // Fetch chunk from the blockchain using the current chunk ID
                const chunkData = await contract.getChunk(chunkIds[currentChunkIndex]);

                // Convert hex string to ArrayBuffer
                const segmentBuffer = hexToArrayBuffer(chunkData);

                // Check if sourceBuffer is too big
                await waitForSourceBuffer();
                sourceBuffer.appendBuffer(segmentBuffer);
                currentChunkIndex++;

                // Update stats
                chunksDownloaded++;
                totalBytesDownloaded += segmentBuffer.byteLength;
                updateStats();

                // Wait for the segment to be processed before loading the next one
                sourceBuffer.addEventListener('updateend', () => {
                    setTimeout(loadNextSegment, delay);
                }, { once: true });
            } catch (error) {
                console.error('Error loading segment:', error);
                mediaSource.endOfStream();
            }
        }

        function hexToArrayBuffer(hexString) {
            // Remove '0x' prefix if present
            const cleanHexString = hexString.startsWith('0x') ? hexString.slice(2) : hexString;
            const bytes = new Uint8Array(cleanHexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            return bytes.buffer;
        }

        function waitForSourceBuffer() {
            return new Promise((resolve) => {
                const checkBuffer = () => {
                    const sizeThreshold = 10 * 1024 * 1024; // 10 MB

                    if (sourceBuffer.buffered.length > 0) {
                        const bufferEnd = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
                        
                        // Estimate buffer size (this is an approximation)
                        const estimatedBufferSize = totalBytesDownloaded - (document.getElementById('videoPlayer').currentTime * (totalBytesDownloaded / bufferEnd));

                        if (estimatedBufferSize < sizeThreshold) {
                            resolve();
                        } else {
                            setTimeout(checkBuffer, 1000); // Check again after 1 second
                        }
                    } else {
                        resolve(); // If there's no buffered data, proceed with appending
                    }
                };
                checkBuffer();
            });
        }

        function updateStats() {
            document.getElementById('chunksDownloaded').textContent = chunksDownloaded;
            const mbsDownloaded = (totalBytesDownloaded / (1024 * 1024)).toFixed(2);
            document.getElementById('mbsDownloaded').textContent = mbsDownloaded;
        }

        // Initialize the video loading
        loadVideo();

        // Add event listener for connect wallet button
        document.getElementById('connectWalletBtn').addEventListener('click', connectWallet);

        // Error handling for video element
        const video = document.getElementById('videoPlayer');
        video.addEventListener('error', function () {
            console.error('Video error:', video.error);
            document.getElementById('fileName').textContent = 'Error: Failed to load video';
        });

        // Add more specific error handling
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            document.getElementById('fileName').textContent = 'Error: An unexpected error occurred';
        });
    </script>

</head>

<body>
    <h1><a href="/">Onchain Video</a> Player</h1>
    <p id="instructionText">Start video by connecting a wallet - this site requires web3 transaction access, since all the videos are stored on the blockchain</p>
    
    <button id="connectWalletBtn">Connect Wallet</button>

    <video id="videoPlayer" controls style="max-width: 400px;"></video>
    <div id="stats" style="display: none;">
        <p><span id="fileName">Loading...</span></p>
        <p><span id="mbsDownloaded">0.00</span> MB downloaded from <span id="chunksDownloaded">0</span> blockchain transactions.</p>
    </div>
</body>

</html>