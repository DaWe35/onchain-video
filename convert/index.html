<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onchain Video Uploader</title>
    <script src="/convert/ffmpeg.min.js"></script>
    <script src="/convert/ffmpeg-core.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js" integrity="sha512-f+t6//rz3Iy3hp1CiwtsigYtyWuGk7bf6xl2RTOPvmyMIfTQJ4iy6Lg1dah1bsLQ9SLideJGicgmOkBsBXP1aA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
    <h1>Onchain Video Uploader</h1>
    <div id="fileInputContainer">
        <p>Select a video file to upload:</p>
        <input type="file" id="videoInput" accept="video/*">
        <p>ðŸ›ˆ Start with a really small file - 1MB video will fill ~25 entire blocks and ask you to sign 25 times.</p>
        <p>ðŸ›ˆ If you have gas issues, try to set the gas limit manually to 29700000.</p>
    </div>
    <div id="resolutionSelector" style="display: none;">
        <p>Select the desired video height:</p>
        <select id="resolutionSelect">
            <option value="90">90p</option>
            <option value="144">144p</option>
            <option value="240">240p</option>
            <option value="360">360p</option>
            <option value="480">480p</option>
            <option value="720">720p</option>
            <option value="1080">1080p</option>
        </select>
        <button id="convertBtn">Convert</button>
    </div>
    <div id="selectedFileInfo" style="display: none;"></div>
    <div id="progressContainer" style="display: none;">
        <progress id="progressBar" value="0" max="100"></progress>
        <span id="progressText">0%</span>
    </div>
    <div id="status"></div>
    <button id="connectWalletBtn" style="display: none;">Connect Wallet</button>
    <button id="switchNetworkBtn" style="display: none;">Switch to Blast Sepolia</button>
    <button id="createVideoBtn" style="display: none;">Create Onchain Video</button>
    <button id="uploadChunksBtn" style="display: none;">Upload Chunks (0/0)</button>
    <div id="videoInfo" style="display: none;"></div>
    <div id="walletStatus" style="display: none;">Connecting wallet...</div>
    <button id="retryUploadBtn" style="display: none;">Retry Upload</button>

    <script>
        // Constants and global variables
        const { createFFmpeg, fetchFile } = FFmpeg;
        const contractAddress = "0xe9b1324f531a4603eb5d1a739e4ee25a5c824890";
        const CHUNK_SIZE = 40 * 1024; // 40 KB
        let provider, signer, contract;
        let convertedVideo, chunkCount, uploadedChunks = 0;
        let contractABI, isABILoaded = false, isFFmpegLoaded = false;

        // FFmpeg initialization
        const ffmpeg = createFFmpeg({ 
            log: true,
            progress: ({ ratio }) => {
                const percent = (ratio * 100).toFixed(2);
                document.getElementById('progressBar').value = percent;
                document.getElementById('progressText').textContent = `${percent}%`;
            }
        });

        // Utility functions
        async function loadFFmpeg() {
            if (!isFFmpegLoaded) {
                await ffmpeg.load();
                isFFmpegLoaded = true;
            }
        }

        async function loadABI() {
            try {
                const response = await fetch('/contract/abi.json');
                contractABI = await response.json();
                isABILoaded = true;
                console.log("ABI loaded successfully");
            } catch (error) {
                console.error("Failed to load ABI:", error);
            }
        }

        function isContractInitialized() {
            return contract !== undefined && contract !== null;
        }

        function updateUploadButton() {
            const btn = document.getElementById('uploadChunksBtn');
            btn.textContent = `Upload Chunks (${uploadedChunks}/${chunkCount})`;
            if (uploadedChunks === chunkCount) {
                btn.disabled = true;
            }
        }

        // Main functions
        async function connectWallet() {
            const walletStatus = document.getElementById('walletStatus');
            walletStatus.style.display = 'block';
            walletStatus.textContent = 'Connecting wallet...';

            if (typeof window.ethereum !== 'undefined') {
                try {
                    if (!isABILoaded) {
                        throw new Error("ABI not loaded. Please refresh the page and try again.");
                    }
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider = new ethers.BrowserProvider(window.ethereum);
                    signer = await provider.getSigner();
                    contract = new ethers.Contract(contractAddress, contractABI, signer);
                    document.getElementById('connectWalletBtn').style.display = 'none';
                    checkNetwork();
                    console.log("Contract initialized:", isContractInitialized());
                    console.log("Available contract methods:", Object.keys(contract));
                    walletStatus.textContent = 'Wallet connected successfully!';
                    setTimeout(() => { walletStatus.style.display = 'none'; }, 3000);
                } catch (error) {
                    console.error('Failed to connect wallet:', error);
                    walletStatus.textContent = error.message || 'Failed to connect wallet. Please try again.';
                }
            } else {
                walletStatus.textContent = 'Please install MetaMask to use this feature.';
            }
        }

        async function checkNetwork() {
            const network = await provider.getNetwork();
            if (network.name !== 'blast-sepolia') {
                document.getElementById('switchNetworkBtn').style.display = 'inline';
            } else {
                document.getElementById('createVideoBtn').style.display = 'inline';
            }
        }

        async function switchNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0xa0c71fd' }], // Blast Sepolia chain ID
                });
                document.getElementById('switchNetworkBtn').style.display = 'none';
                document.getElementById('createVideoBtn').style.display = 'inline';
            } catch (error) {
                console.error('Failed to switch network:', error);
                document.getElementById('status').textContent = 'Failed to switch network. Please try again.';
            }
        }

        async function createOnchainVideo() {
            const inputFile = document.getElementById('videoInput').files[0];
            const createVideoBtn = document.getElementById('createVideoBtn');
            const statusElement = document.getElementById('status');

            try {
                if (!isContractInitialized()) {
                    throw new Error("Contract is not initialized. Please connect your wallet first.");
                }
                createVideoBtn.style.display = 'none';
                statusElement.textContent = 'Creating onchain video... Please wait for confirmation.';
                
                // Create metadata object with codec information
                const metadata = {
                    codec: 'video/mp4; codecs="avc1.64002A, mp4a.40.5"'
                };
                
                const tx = await contract.createOnchainVideo(inputFile.name, 0, JSON.stringify(metadata));
                await tx.wait();
                
                const address = await signer.getAddress();
                const videoCount = await contract.getVideoCount(address);
                const videoId = (videoCount - BigInt(1)).toString();
                console.log("Video ID:", videoId);
                
                statusElement.textContent = `Onchain video created. Starting chunk uploads... (make sure gas limit is just below 30M, eg. 29700000)`;
                uploadChunksBatch(videoId);
            } catch (error) {
                console.error('Failed to create onchain video:', error);
                statusElement.textContent = 'Failed to create onchain video. Please try again.';
                createVideoBtn.style.display = 'inline';
            }
        }

        async function uploadChunksBatch(videoId) {
            const statusElement = document.getElementById('status');
            const retryButton = document.getElementById('retryUploadBtn');

            for (let i = uploadedChunks; i < chunkCount; i++) {
                const chunk = convertedVideo.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
                try {
                    const tx = await contract.uploadChunk(ethers.hexlify(chunk), videoId, {
                        gasLimit: 29700000
                    });
                    statusElement.textContent = `Uploading chunk ${i + 1}/${chunkCount}... Transaction sent.`;
                    uploadedChunks++;
                    updateUploadButton();
                } catch (error) {
                    console.error(`Failed to upload chunk ${i + 1}:`, error);
                    lastFailedChunkIndex = i;
                    statusElement.textContent = `Failed to upload chunk ${i + 1}. Click 'Retry Upload' to continue.`;
                    statusElement.innerHTML += `<br>ps: if you have gas issues, try to set the gas limit manually to 29700000.`;
                    retryButton.style.display = 'inline';
                    return;
                }
            }

            displayVideoInfo(videoId);
            statusElement.textContent = 'All chunks uploaded successfully!';
            retryButton.style.display = 'none';
        }

        async function retryUpload() {
            const retryButton = document.getElementById('retryUploadBtn');
            retryButton.style.display = 'none';
            
            if (lastFailedChunkIndex !== -1) {
                uploadedChunks = lastFailedChunkIndex;
                updateUploadButton();
                
                // Get the current video ID
                const address = await signer.getAddress();
                const videoCount = await contract.getVideoCount(address);
                const videoId = (videoCount - BigInt(1)).toString();
                
                await uploadChunksBatch(videoId);
            }
        }

        async function displayVideoInfo(videoId) {
            try {
                const video = await contract.getVideo(videoId);
                console.log("Video:", video);
                const videoInfo = document.getElementById('videoInfo');
                
                const filename = video.filename || 'N/A';
                const duration = video.duration ? video.duration.toString() : 'N/A';
                const chunkCount = video.chunkIds ? video.chunkIds.length.toString() : 'N/A';
                
                videoInfo.innerHTML = `
                    <h2>Video Information</h2>
                    <h3>Play: <a href="/?video=${videoId}">/?video=${videoId}</a></h3>
                    <p>Filename: ${filename}</p>
                    <p>Duration: ${duration}</p>
                    <p>Chunk Count: ${chunkCount}</p>
                `;
                videoInfo.style.display = 'block';
            } catch (error) {
                console.error('Error displaying video info:', error);
                document.getElementById('status').textContent = 'Failed to retrieve video information. Please try again.';
            }
        }

        async function convertToFragmentedMP4(inputFile) {
            const statusElement = document.getElementById('status');
            const progressContainer = document.getElementById('progressContainer');
            const fileInputContainer = document.getElementById('fileInputContainer');
            const selectedFileInfo = document.getElementById('selectedFileInfo');
            const resolutionSelector = document.getElementById('resolutionSelector');
            
            statusElement.textContent = 'Converting...';
            progressContainer.style.display = 'block';
            fileInputContainer.style.display = 'none';
            resolutionSelector.style.display = 'none';
            selectedFileInfo.textContent = `Selected file: ${inputFile.name}`;
            selectedFileInfo.style.display = 'block';

            try {
                await loadFFmpeg();
                const inputFileName = 'input_video';
                const outputFileName = 'output_fragmented.mp4';
                ffmpeg.FS('writeFile', inputFileName, await fetchFile(inputFile));

                const height = document.getElementById('resolutionSelect').value;

                await ffmpeg.run(
                    '-i', inputFileName,
                    '-f', 'lavfi',
                    '-i', 'anullsrc=channel_layout=stereo:sample_rate=44100',
                    '-c:v', 'libx264', '-profile:v', 'main', '-level:v', '4.2',
                    '-vf', `scale=-2:${height}`,
                    '-c:a', 'aac', '-b:a', '128k',
                    '-shortest',
                    '-movflags', 'frag_keyframe+empty_moov+default_base_moof',
                    '-f', 'mp4',
                    outputFileName
                );
                const data = ffmpeg.FS('readFile', outputFileName);
                convertedVideo = new Uint8Array(data.buffer);
                chunkCount = Math.ceil(convertedVideo.length / CHUNK_SIZE);
                document.getElementById('connectWalletBtn').style.display = 'inline';
                
                const convertedSizeInMB = (convertedVideo.length / (1024 * 1024)).toFixed(2);
                statusElement.innerHTML = `<br>Conversion complete!<br>
                    ${chunkCount + 1} transactions will be required to upload ${convertedSizeInMB} MB to the blockchain ðŸ˜²<br><br>
                    Please connect your wallet to continue.`;
            } catch (error) {
                console.error('Conversion error:', error);
                statusElement.textContent = 'Conversion failed. Please try again.';
                fileInputContainer.style.display = 'block';
                resolutionSelector.style.display = 'none';
                selectedFileInfo.style.display = 'none';
            } finally {
                progressContainer.style.display = 'none';
            }
        }

        // Event listeners
        document.getElementById('videoInput').addEventListener('change', async (event) => {
            const inputFile = event.target.files[0];
            if (inputFile) {
                document.getElementById('fileInputContainer').style.display = 'none';
                document.getElementById('resolutionSelector').style.display = 'block';
                document.getElementById('selectedFileInfo').textContent = `Selected file: ${inputFile.name}`;
                document.getElementById('selectedFileInfo').style.display = 'block';
            }
        });

        document.getElementById('convertBtn').addEventListener('click', async () => {
            const inputFile = document.getElementById('videoInput').files[0];
            if (inputFile) {
                await convertToFragmentedMP4(inputFile);
            }
        });

        document.getElementById('connectWalletBtn').addEventListener('click', connectWallet);
        document.getElementById('switchNetworkBtn').addEventListener('click', switchNetwork);
        document.getElementById('createVideoBtn').addEventListener('click', createOnchainVideo);
        document.getElementById('uploadChunksBtn').addEventListener('click', uploadChunksBatch);
        document.getElementById('retryUploadBtn').addEventListener('click', retryUpload);

        // Initialize
        loadABI();
    </script>
</body>
</html>